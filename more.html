<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Apify Actor Runner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>
<body class="bg-gray-100 p-8 min-h-screen">

    <div class="max-w-4xl mx-auto bg-white rounded-xl shadow-2xl p-8 space-y-8 border border-gray-200">
        <header class="text-center space-y-2">
            <h1 class="text-4xl font-extrabold text-gray-900">Apify Actor Runner</h1>
            <p class="text-gray-500 text-lg">Authenticate, select an actor, and run it with dynamic inputs.</p>
        </header>

        <!-- API Key Input Section -->
        <div class="bg-gray-50 p-6 rounded-lg border border-gray-200 shadow-inner">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">Apify API Key</h3>
            <div class="flex flex-col sm:flex-row gap-4 items-center">
                <input
                    type="password"
                    id="apiKeyInput"
                    placeholder="Enter your Apify API Key"
                    class="flex-grow w-full sm:w-auto p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors duration-200"
                >
                <button
                    id="authButton"
                    class="w-full sm:w-auto px-6 py-3 font-semibold text-white bg-blue-600 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-transform duration-200 active:scale-95"
                >
                    Authenticate & Fetch Actors
                </button>
            </div>
        </div>

        <!-- Actor Selector Section -->
        <div id="actorSelectorSection" class="hidden bg-gray-50 p-6 rounded-lg border border-gray-200 shadow-inner">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">Select an Actor</h3>
            <select
                id="actorSelect"
                class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-colors duration-200"
            ></select>
        </div>

        <!-- Actor Input Form Section -->
        <div id="actorFormSection" class="hidden bg-gray-50 p-6 rounded-lg border border-gray-200 shadow-inner">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">Actor Input Form</h3>
            <div id="formContainer" class="space-y-4">
                <!-- Dynamic form fields will be injected here -->
            </div>
            <div id="formMessage" class="mt-4">
                <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4 rounded-md">
                    <p class="text-sm text-yellow-700">This actor has no input schema or its schema is empty. No form fields to display.</p>
                </div>
            </div>
            <button
                id="runActorButton"
                class="hidden w-full mt-6 px-6 py-3 font-semibold text-white bg-green-600 rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 transition-transform duration-200 active:scale-95"
            >
                Run Actor
            </button>
        </div>

        <!-- Status Display Section -->
        <div id="statusDisplay" class="bg-gray-50 p-6 rounded-lg border border-gray-200 shadow-inner hidden">
            <h3 class="text-2xl font-bold text-gray-800 mb-4">Status</h3>
            <div id="statusMessage" class="text-lg text-gray-700"></div>
            <div id="errorMessage" class="text-lg text-red-600 mt-2"></div>
            <div id="results" class="mt-4 space-y-2 text-sm text-gray-800"></div>
        </div>

    </div>

    <script>
        // DOM Elements
        const apiKeyInput = document.getElementById('apiKeyInput');
        const authButton = document.getElementById('authButton');
        const actorSelectorSection = document.getElementById('actorSelectorSection');
        const actorSelect = document.getElementById('actorSelect');
        const actorFormSection = document.getElementById('actorFormSection');
        const formContainer = document.getElementById('formContainer');
        const formMessage = document.getElementById('formMessage');
        const runActorButton = document.getElementById('runActorButton');
        const statusDisplay = document.getElementById('statusDisplay');
        const statusMessageDiv = document.getElementById('statusMessage');
        const errorMessageDiv = document.getElementById('errorMessage');
        const resultsDiv = document.getElementById('results');

        let apiKey = '';
        let selectedActorId = '';
        let formData = {};

        // Utility function to display status messages
        const setStatus = (message, isError = false) => {
            statusDisplay.classList.remove('hidden');
            if (isError) {
                errorMessageDiv.textContent = message;
                statusMessageDiv.textContent = '';
            } else {
                statusMessageDiv.textContent = message;
                errorMessageDiv.textContent = '';
            }
        };

        const clearStatus = () => {
            statusDisplay.classList.add('hidden');
            statusMessageDiv.textContent = '';
            errorMessageDiv.textContent = '';
            resultsDiv.innerHTML = '';
        };

        // Function to render the dynamic form based on the schema
        const renderForm = (schema) => {
            formContainer.innerHTML = ''; // Clear previous form
            formMessage.classList.add('hidden');
            runActorButton.classList.add('hidden');
            formData = {}; // Reset form data

            // Check if the schema has properties
            if (schema && schema.properties && Object.keys(schema.properties).length > 0) {
                formMessage.classList.add('hidden');
                runActorButton.classList.remove('hidden');

                for (const key in schema.properties) {
                    const property = schema.properties[key];
                    const label = document.createElement('label');
                    label.textContent = property.title || key;
                    label.setAttribute('for', key);
                    label.className = 'block text-sm font-medium text-gray-700 mt-2';

                    let input;
                    // Handle different input types
                    switch (property.type) {
                        case 'integer':
                        case 'number':
                            input = document.createElement('input');
                            input.type = 'number';
                            break;
                        case 'boolean':
                            input = document.createElement('input');
                            input.type = 'checkbox';
                            input.checked = property.default !== undefined ? property.default : false;
                            break;
                        case 'array':
                        case 'object':
                            // For complex types, use a textarea for JSON input
                            input = document.createElement('textarea');
                            input.rows = 4;
                            const prefilledValue = property.default !== undefined ? JSON.stringify(property.default, null, 2) : '';
                            input.value = prefilledValue;
                            break;
                        case 'string':
                        default:
                            input = document.createElement('input');
                            input.type = 'text';
                            input.value = property.default || '';
                            break;
                    }
                    input.id = key;
                    input.name = key;
                    input.placeholder = property.description || '';
                    input.className = 'mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 transition-colors duration-200';

                    formContainer.appendChild(label);
                    formContainer.appendChild(input);

                    // Initialize formData with default values
                    formData[key] = input.type === 'checkbox' ? input.checked : input.value;
                }
            } else {
                formMessage.classList.remove('hidden');
            }
        };

        // Event listener for the Authenticate button
        authButton.addEventListener('click', async () => {
            apiKey = apiKeyInput.value.trim();
            if (!apiKey) {
                setStatus('Please enter a valid API key.', true);
                return;
            }

            clearStatus();
            setStatus('Fetching actors...');
            authButton.disabled = true;
            actorSelectorSection.classList.add('hidden');
            actorFormSection.classList.add('hidden');
            
            try {
                console.log('Attempting to fetch actors from Apify API...');
                const response = await fetch(`https://api.apify.com/v2/acts?token=${apiKey}&limit=1000`);
                const data = await response.json();
                console.log('Apify API response for actors:', data);

                if (data.error) {
                    throw new Error(data.error.message || 'Error fetching actors.');
                }

                if (data.data.items.length === 0) {
                    setStatus('Authentication successful, but no public actors were found in your account.', true);
                    return;
                }

                setStatus('Actors fetched successfully.');
                actorSelectorSection.classList.remove('hidden');

                // Populate the dropdown
                actorSelect.innerHTML = '';
                data.data.items.forEach(actor => {
                    const option = document.createElement('option');
                    option.value = actor.id;
                    option.textContent = actor.name || actor.id;
                    actorSelect.appendChild(option);
                });

                // Trigger schema fetch for the first actor
                if (data.data.items.length > 0) {
                    selectedActorId = data.data.items[0].id;
                    fetchActorSchema();
                }

            } catch (err) {
                console.error('Error fetching actors:', err);
                setStatus(`Failed to fetch actors: ${err.message}`, true);
            } finally {
                authButton.disabled = false;
            }
        });

        // Event listener for the actor dropdown change
        actorSelect.addEventListener('change', (event) => {
            selectedActorId = event.target.value;
            fetchActorSchema();
        });

        // Function to fetch the actor's input schema
        const fetchActorSchema = async () => {
            if (!selectedActorId || !apiKey) {
                return;
            }

            clearStatus();
            setStatus('Fetching actor schema...');
            actorFormSection.classList.add('hidden');
            
            try {
                console.log(`Attempting to fetch schema for actor ID: ${selectedActorId}`);
                const response = await fetch(`https://api.apify.com/v2/actors/${selectedActorId}/input-schema?token=${apiKey}`);
                
                // Check for a 404 response gracefully
                if (!response.ok) {
                    console.log(`Actor ${selectedActorId} does not have a public input schema. Status: ${response.status}`);
                    setStatus('This actor does not have a public input schema.', true);
                    actorFormSection.classList.remove('hidden');
                    formContainer.innerHTML = '';
                    formMessage.classList.remove('hidden');
                    runActorButton.classList.add('hidden');
                    return;
                }
                
                const data = await response.json();
                console.log(`Apify API response for schema of actor ${selectedActorId}:`, data);

                if (data.error) {
                    throw new Error(data.error.message || 'Error fetching actor schema.');
                }

                setStatus('Input schema fetched successfully. Rendering form...');
                actorFormSection.classList.remove('hidden');
                renderForm(data);

            } catch (err) {
                console.error('Error fetching actor schema:', err);
                setStatus(`Failed to fetch actor schema: ${err.message}`, true);
                actorFormSection.classList.remove('hidden');
                formContainer.innerHTML = '';
                formMessage.classList.remove('hidden');
                runActorButton.classList.add('hidden');
            }
        };

        // Event listener for the run actor button
        runActorButton.addEventListener('click', async () => {
            if (!selectedActorId || !apiKey) {
                setStatus('Please select an actor and provide an API key.', true);
                return;
            }
            
            clearStatus();
            setStatus('Executing actor...');
            runActorButton.disabled = true;

            const finalFormData = {};
            // Gather form data from rendered inputs
            for (const key in formData) {
                const inputElement = document.getElementById(key);
                if (inputElement) {
                    // Handle different input types for final payload
                    if (inputElement.type === 'checkbox') {
                        finalFormData[key] = inputElement.checked;
                    } else if (inputElement.tagName === 'TEXTAREA') {
                        try {
                            finalFormData[key] = JSON.parse(inputElement.value);
                        } catch (e) {
                            finalFormData[key] = inputElement.value;
                        }
                    } else {
                        finalFormData[key] = inputElement.value;
                    }
                }
            }
            
            try {
                console.log('Attempting to run actor with payload:', finalFormData);
                const runResponse = await fetch(`https://api.apify.com/v2/actors/${selectedActorId}/runs?token=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(finalFormData),
                });
                const runData = await runResponse.json();
                console.log('Apify API response for actor run:', runData);

                if (runData.error) {
                    throw new Error(runData.error.message || 'Error starting actor run.');
                }

                const runId = runData.data.id;
                setStatus(`Actor started with ID: ${runId}. Waiting for results...`);

                // Function to poll for run status
                const checkRunStatus = async () => {
                    const statusResponse = await fetch(`https://api.apify.com/v2/acts/${runData.data.actId}/runs/${runId}?token=${apiKey}`);
                    const statusData = await statusResponse.json();
                    const status = statusData.data.status;
                    console.log(`Current run status: ${status}`);

                    if (status === 'SUCCEEDED') {
                        setStatus('Run succeeded! Fetching dataset...');
                        const datasetResponse = await fetch(`https://api.apify.com/v2/datasets/${statusData.data.defaultDatasetId}/items?token=${apiKey}`);
                        const datasetItems = await datasetResponse.json();
                        console.log('Dataset items:', datasetItems);
                        
                        if (datasetItems.length > 0) {
                            resultsDiv.innerHTML = '<h4 class="font-bold">Results:</h4>';
                            datasetItems.forEach(item => {
                                const pre = document.createElement('pre');
                                pre.className = 'bg-gray-200 p-2 rounded-md overflow-x-auto';
                                pre.textContent = JSON.stringify(item, null, 2);
                                resultsDiv.appendChild(pre);
                            });
                        } else {
                            resultsDiv.innerHTML = '<p>No results found in the dataset.</p>';
                        }

                        setStatus('Run complete.');
                        runActorButton.disabled = false;
                        return;
                    }

                    if (status === 'FAILED' || status === 'ABORTED') {
                        setStatus(`Actor run ${status.toLowerCase()}. Check the Apify console for details.`, true);
                        runActorButton.disabled = false;
                        return;
                    }

                    setTimeout(checkRunStatus, 5000);
                };

                setTimeout(checkRunStatus, 5000);
            } catch (err) {
                console.error('Error running actor:', err);
                setStatus(`Failed to run actor: ${err.message}`, true);
                runActorButton.disabled = false;
            }
        });
    </script>
</body>
</html>
